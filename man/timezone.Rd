% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/timezone.r
\name{timezone}
\alias{timezone}
\alias{force_tz}
\alias{force_tz.default}
\alias{force_tz.datetime_offset}
\alias{with_tz}
\alias{with_tz.default}
\alias{with_tz.datetime_offset}
\title{Change timezones}
\usage{
force_tz(time, tzone = "", roll = FALSE)

\method{force_tz}{default}(time, tzone = "", roll = FALSE)

\method{force_tz}{datetime_offset}(time, tzone = "", roll = FALSE)

with_tz(time, tzone = "")

\method{with_tz}{default}(time, tzone = "")

\method{with_tz}{datetime_offset}(time, tzone = "")
}
\arguments{
\item{time}{A datetime object.}

\item{tzone}{A timezone string.
\code{force_tz.datetime_offset()} allows a vector of different valued time zones (in contrast \code{\link[lubridate:force_tz]{lubridate::force_tz()}} allows only one).}

\item{roll}{Used by \code{\link[lubridate:force_tz]{lubridate::force_tz()}} but ignored by \code{force_tz.datetime_offset()}.}
}
\description{
\code{force_tz()} returns a datetime with the same clock time as the input but in the new time zone
(so will likely result in a different global UTC datetime).
\code{with_tz()} returns a datetime with the same global UTC datetime as the input but in the new time zone.
}
\details{
Since \code{lubridate} doesn't make \code{\link[lubridate:force_tz]{lubridate::force_tz()}} or \code{\link[lubridate:with_tz]{lubridate::with_tz()}} generic we
define a generic version which
by default uses the \code{lubridate} version but also has a special \code{\link[=datetime_offset]{datetime_offset()}} method.
}
\examples{
 dt0 <- as_datetime_offset("1918-11-11T11:11:11", tz = "GMT")
 print(dt0)
 if ("US/Pacific" \%in\% OlsonNames()) {
   # `force_tz()` doesn't change "clock" time but may change global UTC time
   dt <- force_tz(dt0, "US/Pacific")
   print(dt)
   # `with_tz()` doesn't change global UTC time but my change "clock" time
   dt <- with_tz(dt0, "US/Pacific")
   print(dt)
 }
}
\seealso{
\link[=tz]{getset_lubridate} and \link[=tz<-]{getset_lubridate}.
}
