% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/timezone.r
\name{timezone}
\alias{timezone}
\alias{force_tz}
\alias{force_tz.default}
\alias{force_tz.datetime_offset}
\title{Change timezones}
\usage{
force_tz(time, tzone = "", roll = FALSE)

\method{force_tz}{default}(time, tzone = "", roll = FALSE)

\method{force_tz}{datetime_offset}(time, tzone = "", roll = FALSE)
}
\arguments{
\item{time}{A datetime object.}

\item{tzone}{A timezone string.
\code{force_tz.datetime_offset()} allows a vector of different valued time zones (in contrast \code{\link[lubridate:force_tz]{lubridate::force_tz()}} allows only one).}

\item{roll}{Used by \code{\link[lubridate:force_tz]{lubridate::force_tz()}} but ignored by \code{force_tz.datetime_offset()}.}
}
\description{
\code{force_tz()} returns a datetime with the same clock time as the input but in the new time zone
(so will likely result in a different UTC datetime).
}
\details{
Since \code{lubridate} doesn't make \code{\link[lubridate:force_tz]{lubridate::force_tz()}} generic we define a generic version which
by default uses the \code{lubridate} version but has a special \code{\link[=datetime_offset]{datetime_offset()}} method.
}
\examples{
 dt <- as_datetime_offset("1918-11-11T11:11:11")
 print(dt)
 if ("Europe/Paris" \%in\% OlsonNames()) {
   dt <- force_tz(dt, "Europe/Paris")
   print(dt)
 }
 # `force_tz()` doesn't change "clock" time but may change global UTC time
 if ("US/Pacific" \%in\% OlsonNames()) {
   dt <- force_tz(dt, "US/Pacific")
   print(dt)
 }
}
\seealso{
\link[=tz]{getset_lubridate} and \link[=tz<-]{getset_lubridate}.
}
