% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/precision.r
\name{datetime_precision}
\alias{datetime_precision}
\alias{datetime_precision.datetimeoffset}
\alias{datetime_precision.clock_calendar}
\alias{datetime_precision.clock_time_point}
\alias{datetime_precision.clock_zoned_time}
\title{Datetime precision}
\usage{
datetime_precision(x, ...)

\method{datetime_precision}{datetimeoffset}(x, range = FALSE, unspecified = FALSE, ...)

\method{datetime_precision}{clock_calendar}(x, ...)

\method{datetime_precision}{clock_time_point}(x, ...)

\method{datetime_precision}{clock_zoned_time}(x, ...)
}
\arguments{
\item{x}{A datetime vector.  Either \code{\link[=datetimeoffset]{datetimeoffset()}}, a "clock" "calendar", or a "clock" "time".}

\item{...}{Reserved for other methods.}

\item{range}{If \code{TRUE} return just the minimum and maximum "precision".}

\item{unspecified}{If \code{TRUE} use the smallest non-missing component's as the precision even
if there is a missing value for a larger component.}
}
\value{
A character vector of precisions ("year", "month", "day", "hour", "minute", "second", or "nanosecond").
}
\description{
\code{datetime_precision()} returns the "precision" of a datetime vector's datetimes.
}
\examples{
  dts <- as_datetimeoffset(c("2020", "2020-04-10", "2020-04-10T10:10"))
  datetime_precision(dts)
  datetime_precision(dts, range = TRUE)

  dt <- datetimeoffset(2020, NA_integer_, 10)
  datetime_precision(dt)
  datetime_precision(dt, unspecified = TRUE)

  library("clock")
  datetime_precision(year_month_day(1918, 11, 11))
  datetime_precision(sys_time_now())
  datetime_precision(zoned_time_now(Sys.timezone()))
}
